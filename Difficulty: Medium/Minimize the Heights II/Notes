â“ What We Are Doing
Letâ€™s break this down:

Step 1: Sort the array
[1, 5, 8, 10] â†’ Sorted âœ…

Because we need to talk about smallest and largest values easily.

Step 2: Initial Difference (Before Any Change)
Biggest = 10
Smallest = 1

diff = 10 - 1 = 9
We want to reduce this number!

Step 3: Try Changing Values with +K and -K
We are going to try different ways of choosing:

Some elements to do +K

Other elements to do -K

And see which gives the smallest difference between tallest and shortest tower.

ğŸ’¡ Very Clear Approach (Split Logic)
We try this logic:

For a position i (from 0 to n-2)

All elements from index 0 to i â†’ do +K

All elements from i+1 to end â†’ do -K

Then calculate:

Minimum value in new array

Maximum value in new array

Take the difference â†’ keep the smallest one

ğŸ§® Dry Run
Letâ€™s do the dry run step-by-step:

âœ… Initial Setup
Sorted array: [1, 5, 8, 10]
k = 2
We are going to try splitting after every index from 0 to 2.

ğŸ”¹ Try Split at i = 0
Apply +K to: [1] â†’ [3]
Apply -K to: [5, 8, 10] â†’ [3, 6, 8]
Now the array is:
[3, 3, 6, 8]
Smallest = 3
Largest = 8
Difference = 5 âœ…

ğŸ”¹ Try Split at i = 1
+K â†’ [1, 5] â†’ [3, 7]
-K â†’ [8, 10] â†’ [6, 8]
New array:
[3, 7, 6, 8]
Smallest = 3
Largest = 8
Difference = 5 âœ…

ğŸ”¹ Try Split at i = 2
+K â†’ [1, 5, 8] â†’ [3, 7, 10]
-K â†’ [10] â†’ [8]
New array:  [3, 7, 10, 8]
Smallest = 3
Largest = 10
Difference = 7 âŒ (Worse)

âœ… Best Result
Best minimum difference = 5

ğŸ’¡ Summary of Intuition
We:

Try different ways to balance the tall and short towers.

Use +K to make small towers bigger.

Use -K to make big towers smaller.

Check how close the smallest and tallest become.

Keep the best one.












ğŸ’¡ First, What's Our Goal Again?
We want to minimize the difference between the tallest and shortest tower after either adding or subtracting K from each tower exactly once.

âœ… High-Level Plan:
We already did a dry run where we try:

Increase heights of the first i + 1 towers by K

Decrease heights of the rest towers from i+1 to n-1 by K

So this loop does that automatically in a smart way.

ğŸ’¡ Step-by-Step Explanation
Letâ€™s walk through each line of that code ğŸ‘‡

ğŸ” for(int i = 0; i < n - 1; i++)
We are trying every possible "split point" in the array:

Where we say:
Towers 0 to i â†’ increase by K
Towers i+1 to n-1 â†’ decrease by K

We try all valid splits from start to second-last index.

ğŸ§® Line: int min = Math.min(smallest, arr[i+1] - k);
We are trying to calculate the smallest height in the modified array for this split.

arr[i+1] - k: Because we're decreasing the height of towers from i+1 onward

smallest = arr[0] + k: This is the increased value of the first tower

So we compare both and pick the smaller one â†’ that will be the shortest tower in the new array.

ğŸ§® Line: int max = Math.max(largest, arr[i] + k);
We are calculating the tallest tower after modification.

arr[i] + k: Because we're increasing height up to index i

largest = arr[n - 1] - k: This is the decreased value of the last tower

We compare both and pick the larger one â†’ this will be the tallest tower in the new array.

âš ï¸ Line: if(min < 0) continue;
Very important!
ğŸ‘‰ Because heights canâ€™t be negative, so we skip any case where:

arr[i+1] - k < 0
This happens when we try to reduce a small number by K and it becomes negative â€” which is not allowed.

âœ… Line: ans = Math.min(ans, max - min);
This is the core line â€” update the answer with the smallest height difference weâ€™ve found so far.

We always want:
max - min â†’ as small as possible âœ…
