✅ Input Grid Example:
int[][] grid = {
    {0, 0, 0},
    {0, 1, 0},
    {0, 0, 0}
};
This is a 3x3 grid, where:

0 → allowed cell

1 → blocked cell

We can move only right or down

Start from (0,0) → end at (2,2)

👀 Visual Representation:
(0,0) (0,1) (0,2)
(1,0) (1,1) (1,2)
(2,0) (2,1) (2,2)
🧠 Objective:
Count all valid paths from (0,0) to (2,2) avoiding blocked cells.

✅ Step-by-Step Dry Run:
1. Call: solve(0,0)
grid[0][0] == 0 → OK

not destination → go right and down

2. Call: solve(0,1)
grid[0][1] == 0

Not destination → right & down

3. Call: solve(0,2)
grid[0][2] == 0

Not destination → right & down

4. Call: solve(0,3) → ❌ Out of bounds → returns 0
5. Call: solve(1,2)
grid[1][2] == 0

Go right & down

6. Call: solve(1,3) → ❌ returns 0
7. Call: solve(2,2) ✅ Reached destination → returns 1
→ So solve(1,2) = 1
→ So solve(0,2) = 1

8. Back to solve(0,1), now try solve(1,1)
grid[1][1] == 1 ❌ blocked → return 0
→ So solve(0,1) = right(1) + down(0) = 1

9. Back to solve(0,0), now do solve(1,0)
grid[1][0] == 0

10. solve(1,1) → ❌ blocked → return 0
11. solve(2,0) → ok
12. solve(2,1) → ok
13. solve(2,2) → ✅ destination → return 1
→ solve(2,1) = right(1) + down(0) = 1
→ solve(2,0) = right(1) + down(0) = 1
→ solve(1,0) = right(0) + down(1) = 1

🔁 Final Calculation:
solve(0,0) = right (1) + down (1) = 2
✅ Final Answer: 2
So, there are 2 unique paths from top-left to bottom-right avoiding the blocked cell.

📝 Summary of Memo Table (visited[][]):
Cell	    Value (Ways)
(2,2)	        1
(2,1)	        1
(2,0)	        1
(1,2)	        1
(1,0)	        1
(0,2)	        1
(0,1)	        1
(0,0)	        2 (Final ans)
