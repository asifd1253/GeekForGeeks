âœ… Example:
Letâ€™s use the array:
arr = [3, 2, 5, 10, 7]
Step 1: Initialize dp[]
You are creating a DP array to store the maximum sum at each index:

int dp[] = new int[n + 1];
Now fill the base cases:

dp[0] = arr[0];                         // dp[0] = 3
dp[1] = Math.max(arr[0], arr[1]);       // dp[1] = max(3, 2) = 3
Initial DP state:
i	      dp[i]
0	        3
1	        3
2	
3	
4	

Step 2: Loop from i = 2 to n-1
ğŸ” i = 2
dp[2] = Math.max(arr[2] + dp[0], dp[1]);
       = Math.max(5 + 3, 3)
       = Math.max(8, 3)
       = 8
âœ… We can either:

Take 5 and dp[0] = 3 â†’ total 8

Or skip 5 and take dp[1] = 3

Best is 8.

i	      dp[i]
0	        3
1	        3
2	        8

ğŸ” i = 3
dp[3] = Math.max(arr[3] + dp[1], dp[2]);
       = Math.max(10 + 3, 8)
       = Math.max(13, 8)
       = 13
âœ… We can either:

Take 10 and dp[1] = 3 â†’ total 13

Or skip 10 and take dp[2] = 8

Best is 13.

i	    dp[i]
3	      13

ğŸ” i = 4
dp[4] = Math.max(arr[4] + dp[2], dp[3]);
       = Math.max(7 + 8, 13)
       = Math.max(15, 13)
       = 15
âœ… We can either:

Take 7 and dp[2] = 8 â†’ total 15

Or skip 7 and take dp[3] = 13

Best is 15.

ğŸ”š Final dp[]:
i	dp[i]	Meaning
0	3	Only 3 taken
1	3	max(3, 2)
2	8	max(5 + dp[0] = 8, dp[1] = 3)
3	13	max(10 + dp[1] = 13, dp[2] = 8)
4	15	max(7 + dp[2] = 15, dp[3] = 13)

âœ… Final Answer: dp[4] = 15
ğŸ¯ So what's happening?
You're building up the answer:

At each index, you decide:

Should I take this number and skip previous one, or

Skip this number and take the best answer up to the previous index?

This choice is captured in:
dp[i] = max(arr[i] + dp[i-2], dp[i-1]);
ğŸ’¡ Output:
Max sum without adjacent elements = 15
â†’ by picking 3 + 5 + 7 or 3 + 10 + 2 depending on array
